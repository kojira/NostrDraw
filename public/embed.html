<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NostrDraw Embed</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      background: transparent;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    .container {
      width: 100%;
      height: 100%;
      min-height: 100px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .loading {
      color: #666;
      font-size: 14px;
    }
    .error {
      color: #c00;
      font-size: 14px;
      text-align: center;
      padding: 20px;
    }
    .card-wrapper {
      display: flex;
      flex-direction: column;
      max-width: 100%;
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    .card-image {
      display: block;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    .card-image:hover {
      opacity: 0.9;
    }
    .card-image img, .card-image svg {
      display: block;
      max-width: 100%;
      max-height: 100%;
    }
    .card-footer {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: #fafafa;
      border-top: 1px solid #eee;
      text-decoration: none;
      color: inherit;
      transition: background 0.2s;
    }
    .card-footer:hover {
      background: #f0f0f0;
    }
    .avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #ddd;
      flex-shrink: 0;
      object-fit: cover;
    }
    .user-info {
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }
    .user-name {
      font-size: 13px;
      font-weight: 600;
      color: #333;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .post-time {
      font-size: 11px;
      color: #888;
    }
    .nostr-logo {
      width: 20px;
      height: 20px;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <div class="container" id="container">
    <div class="loading">Loading...</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script>
    const DEFAULT_RELAYS = [
      'wss://yabu.me',
      'wss://r.kojira.io',
      'wss://x.kojira.io',
    ];

    const NOSTRDRAW_KIND = 31898;
    const PROFILE_KIND = 0;

    // URL parameters
    const params = new URLSearchParams(window.location.search);
    const eventId = params.get('id') || params.get('event');
    const relayParam = params.get('relay');
    const relays = relayParam ? [relayParam] : DEFAULT_RELAYS;

    // Format date with seconds
    function formatDateTime(timestamp) {
      const date = new Date(timestamp * 1000);
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      const seconds = String(date.getSeconds()).padStart(2, '0');
      return `${year}/${month}/${day} ${hours}:${minutes}:${seconds}`;
    }

    // Check if string is valid Base64 (allows unpadded base64)
    function isBase64(str) {
      if (!str || str.length === 0) return false;
      // Allow standard base64 characters, padding is optional
      const base64Regex = /^[A-Za-z0-9+/]+={0,2}$/;
      // Reject if it looks like plain text (contains common non-base64 patterns)
      if (/^<|^\s*\{|^\s*\[/.test(str)) return false;
      return base64Regex.test(str);
    }

    // Validate URL to prevent XSS attacks from malicious URLs
    function isValidImageUrl(url) {
      if (!url || typeof url !== 'string') return false;
      
      const trimmedUrl = url.trim().toLowerCase();
      
      // Block dangerous schemes
      const dangerousSchemes = ['javascript:', 'vbscript:', 'data:text/html', 'data:application'];
      for (const scheme of dangerousSchemes) {
        if (trimmedUrl.startsWith(scheme)) {
          return false;
        }
      }
      
      // Allow only http, https, and safe data URLs (images only)
      if (trimmedUrl.startsWith('http://') || trimmedUrl.startsWith('https://')) {
        return true;
      }
      
      // Allow data URLs for images only (not SVG to prevent embedded scripts)
      if (trimmedUrl.startsWith('data:image/') && !trimmedUrl.startsWith('data:image/svg')) {
        return true;
      }
      
      return false;
    }

    // Sanitize CSS style attribute to remove dangerous patterns
    function sanitizeStyle(styleValue) {
      if (!styleValue) return '';
      
      const lowerStyle = styleValue.toLowerCase();
      
      // Dangerous CSS patterns that can execute code
      const dangerousPatterns = [
        /expression\s*\(/gi,           // IE CSS expressions
        /behavior\s*:/gi,              // IE behavior
        /-moz-binding\s*:/gi,          // Firefox XBL binding
        /javascript\s*:/gi,            // javascript: URLs
        /vbscript\s*:/gi,              // vbscript: URLs
        /@import/gi,                   // @import can load external CSS
        /url\s*\(\s*["']?\s*javascript/gi,  // url(javascript:...)
        /url\s*\(\s*["']?\s*data\s*:/gi,    // url(data:...) can be dangerous
      ];
      
      for (const pattern of dangerousPatterns) {
        if (pattern.test(lowerStyle)) {
          return ''; // Remove entire style if dangerous pattern found
        }
      }
      
      return styleValue;
    }

    // Sanitize SVG to prevent XSS attacks
    function sanitizeSvg(svgString) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgString, 'image/svg+xml');
      
      // Check for parse errors
      const parseError = doc.querySelector('parsererror');
      if (parseError) {
        console.error('SVG parse error');
        return null;
      }
      
      const svg = doc.querySelector('svg');
      if (!svg) return null;
      
      // Remove dangerous elements (including style elements that could contain malicious CSS)
      const dangerousElements = ['script', 'foreignObject', 'iframe', 'object', 'embed', 'style'];
      dangerousElements.forEach(tag => {
        svg.querySelectorAll(tag).forEach(el => el.remove());
      });
      
      // Remove event handlers and dangerous attributes from all elements
      const dangerousAttrs = [
        'onload', 'onerror', 'onclick', 'onmouseover', 'onmouseout', 'onmousedown',
        'onmouseup', 'onmousemove', 'onfocus', 'onblur', 'onchange', 'onsubmit',
        'onkeydown', 'onkeyup', 'onkeypress', 'onscroll', 'onwheel', 'ondrag',
        'ondrop', 'onanimationstart', 'onanimationend', 'ontransitionend'
      ];
      
      const allElements = svg.querySelectorAll('*');
      allElements.forEach(el => {
        dangerousAttrs.forEach(attr => {
          el.removeAttribute(attr);
        });
        // Remove javascript: URLs
        ['href', 'xlink:href'].forEach(attr => {
          const val = el.getAttribute(attr);
          if (val && val.toLowerCase().trim().startsWith('javascript:')) {
            el.removeAttribute(attr);
          }
        });
        // Sanitize style attributes
        const styleVal = el.getAttribute('style');
        if (styleVal) {
          const sanitized = sanitizeStyle(styleVal);
          if (sanitized) {
            el.setAttribute('style', sanitized);
          } else {
            el.removeAttribute('style');
          }
        }
      });
      
      // Also check the svg element itself
      dangerousAttrs.forEach(attr => {
        svg.removeAttribute(attr);
      });
      const svgStyle = svg.getAttribute('style');
      if (svgStyle) {
        const sanitized = sanitizeStyle(svgStyle);
        if (sanitized) {
          svg.setAttribute('style', sanitized);
        } else {
          svg.removeAttribute('style');
        }
      }
      
      return svg;
    }

    // Decompress SVG
    function decompressSvg(compressedData) {
      if (!compressedData || !isBase64(compressedData)) {
        return null;
      }
      
      try {
        const binaryStr = atob(compressedData);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }
        const decompressed = pako.inflate(bytes, { to: 'string' });
        return decompressed;
      } catch (e) {
        try {
          const binaryStr = atob(compressedData);
          const bytes = new Uint8Array(binaryStr.length);
          for (let i = 0; i < binaryStr.length; i++) {
            bytes[i] = binaryStr.charCodeAt(i);
          }
          const decompressed = pako.ungzip(bytes, { to: 'string' });
          return decompressed;
        } catch (e2) {
          console.error('Decompression failed:', e2);
          return null;
        }
      }
    }

    // Parse NostrDraw event
    function parseNostrDrawEvent(event) {
      const contentType = event.tags.find(t => t[0] === 'content-type')?.[1] || 'image/svg+xml';
      const encoding = event.tags.find(t => t[0] === 'encoding')?.[1];
      const imageUrl = event.tags.find(t => t[0] === 'image')?.[1];
      // parentEventId is from 'e' tag with 'root' or 'reply' marker, or just any 'e' tag
      const eTag = event.tags.find(t => t[0] === 'e');
      const parentEventId = eTag ? eTag[1] : null;
      
      let svg = null;
      let isDiff = false;
      let content = event.content || '';
      
      if (content.trim().startsWith('{')) {
        try {
          const jsonContent = JSON.parse(content);
          // isDiff is stored in JSON content, not in tags
          isDiff = jsonContent.isDiff === true;
          if (jsonContent.svgCompressed) {
            svg = decompressSvg(jsonContent.svgCompressed);
          } else if (jsonContent.svg) {
            svg = jsonContent.svg;
          }
        } catch (e) {
          console.error('Failed to parse JSON content:', e);
        }
      }
      else if (content.trim().startsWith('<svg') || content.trim().startsWith('<?xml')) {
        svg = content;
      }
      else if (encoding === 'deflate+base64' || encoding === 'binary+gzip+base64') {
        svg = decompressSvg(content);
      }
      else if (isBase64(content)) {
        svg = decompressSvg(content);
      }
      else if (contentType === 'image/svg+xml' && content) {
        svg = content;
      }
      
      return { svg, imageUrl, event, isDiff, parentEventId };
    }

    // Merge parent SVG with diff SVG
    function mergeSvgWithDiff(parentSvg, diffSvg) {
      const parser = new DOMParser();
      const parentDoc = parser.parseFromString(parentSvg, 'image/svg+xml');
      const diffDoc = parser.parseFromString(diffSvg, 'image/svg+xml');
      
      const parentSvgEl = parentDoc.querySelector('svg');
      const diffSvgEl = diffDoc.querySelector('svg');
      
      if (!parentSvgEl || !diffSvgEl) {
        return diffSvg; // Fallback to diff if merge fails
      }
      
      // Copy all child elements from diff to parent
      Array.from(diffSvgEl.childNodes).forEach(node => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          parentSvgEl.appendChild(node.cloneNode(true));
        }
      });
      
      return new XMLSerializer().serializeToString(parentSvgEl);
    }

    // Get full SVG by recursively merging with ancestors
    async function getFullSvg(event, relays) {
      const { svg, isDiff, parentEventId } = parseNostrDrawEvent(event);
      
      if (!isDiff || !parentEventId || !svg) {
        return svg;
      }
      
      // Fetch parent event
      const parentEvent = await fetchEvent(parentEventId, relays);
      if (!parentEvent) {
        return svg; // Return diff if parent not found
      }
      
      // Recursively get parent's full SVG
      const parentFullSvg = await getFullSvg(parentEvent, relays);
      if (!parentFullSvg) {
        return svg;
      }
      
      // Merge parent with diff
      return mergeSvgWithDiff(parentFullSvg, svg);
    }

    // Fetch event from relays
    async function fetchEvent(eventId, relays) {
      for (const relay of relays) {
        try {
          const result = await fetchFromRelay(relay, eventId);
          if (result) return result;
        } catch (e) {
          console.warn(`Failed to fetch from ${relay}:`, e);
        }
      }
      return null;
    }

    function fetchFromRelay(relayUrl, eventId) {
      return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        const subId = 'embed-' + Math.random().toString(36).slice(2);
        let resolved = false;
        
        const timeout = setTimeout(() => {
          if (!resolved) {
            resolved = true;
            ws.close();
            resolve(null);
          }
        }, 5000);
        
        ws.onopen = () => {
          ws.send(JSON.stringify(['REQ', subId, { ids: [eventId] }]));
          ws.send(JSON.stringify(['REQ', subId + '-d', { kinds: [NOSTRDRAW_KIND], '#d': [eventId] }]));
        };
        
        ws.onmessage = (msg) => {
          try {
            const data = JSON.parse(msg.data);
            if (data[0] === 'EVENT' && data[2]) {
              if (!resolved) {
                resolved = true;
                clearTimeout(timeout);
                ws.close();
                resolve(data[2]);
              }
            }
          } catch (e) {
            console.error('Parse error:', e);
          }
        };
        
        ws.onerror = (e) => {
          if (!resolved) {
            resolved = true;
            clearTimeout(timeout);
            reject(e);
          }
        };
      });
    }

    // Fetch profile
    async function fetchProfile(pubkey, relays) {
      for (const relay of relays) {
        try {
          const result = await fetchProfileFromRelay(relay, pubkey);
          if (result) return result;
        } catch (e) {
          console.warn(`Failed to fetch profile from ${relay}:`, e);
        }
      }
      return null;
    }

    function fetchProfileFromRelay(relayUrl, pubkey) {
      return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        const subId = 'profile-' + Math.random().toString(36).slice(2);
        let resolved = false;
        
        const timeout = setTimeout(() => {
          if (!resolved) {
            resolved = true;
            ws.close();
            resolve(null);
          }
        }, 3000);
        
        ws.onopen = () => {
          ws.send(JSON.stringify(['REQ', subId, { kinds: [PROFILE_KIND], authors: [pubkey], limit: 1 }]));
        };
        
        ws.onmessage = (msg) => {
          try {
            const data = JSON.parse(msg.data);
            if (data[0] === 'EVENT' && data[2] && data[2].kind === PROFILE_KIND) {
              if (!resolved) {
                resolved = true;
                clearTimeout(timeout);
                ws.close();
                try {
                  const profile = JSON.parse(data[2].content);
                  resolve(profile);
                } catch (e) {
                  resolve(null);
                }
              }
            } else if (data[0] === 'EOSE') {
              if (!resolved) {
                resolved = true;
                clearTimeout(timeout);
                ws.close();
                resolve(null);
              }
            }
          } catch (e) {
            console.error('Parse error:', e);
          }
        };
        
        ws.onerror = (e) => {
          if (!resolved) {
            resolved = true;
            clearTimeout(timeout);
            reject(e);
          }
        };
      });
    }

    // Render
    async function render() {
      const container = document.getElementById('container');
      
      if (!eventId) {
        container.innerHTML = '<div class="error">No event ID specified.<br>Usage: ?id=EVENT_ID</div>';
        return;
      }
      
      try {
        const event = await fetchEvent(eventId, relays);
        
        if (!event) {
          container.innerHTML = '<div class="error">Event not found</div>';
          return;
        }
        
        const { svg: rawSvg, imageUrl, isDiff, parentEventId } = parseNostrDrawEvent(event);
        
        // If this is a diff card, get full SVG by merging with ancestors
        let svg = rawSvg;
        if (isDiff && parentEventId && rawSvg) {
          svg = await getFullSvg(event, relays);
        }
        
        // Fetch profile
        const profile = await fetchProfile(event.pubkey, relays);
        const displayName = profile?.display_name || profile?.name || event.pubkey.slice(0, 8) + '...';
        const avatarUrl = profile?.picture || '';
        
        // Create wrapper
        const wrapper = document.createElement('div');
        wrapper.className = 'card-wrapper';
        
        // Create image link
        const cardLink = document.createElement('a');
        cardLink.href = `https://kojira.github.io/NostrDraw/?view=${encodeURIComponent(eventId)}`;
        cardLink.target = '_blank';
        cardLink.className = 'card-image';
        
        if (svg) {
          // Sanitize SVG to prevent XSS attacks
          const svgEl = sanitizeSvg(svg);
          if (svgEl) {
            if (!svgEl.getAttribute('width')) {
              svgEl.setAttribute('width', '100%');
            }
            if (!svgEl.getAttribute('height')) {
              svgEl.setAttribute('height', 'auto');
            }
            svgEl.style.width = '100%';
            svgEl.style.height = 'auto';
            svgEl.style.maxWidth = '100%';
            svgEl.style.maxHeight = '100%';
            svgEl.style.display = 'block';
            cardLink.appendChild(svgEl);
          } else {
            // If sanitization fails, show error instead of raw content
            container.innerHTML = '<div class="error">Invalid SVG content</div>';
            return;
          }
        } else if (imageUrl && isValidImageUrl(imageUrl)) {
          const img = document.createElement('img');
          img.src = imageUrl;
          img.alt = 'NostrDraw Card';
          cardLink.appendChild(img);
        } else if (imageUrl) {
          // Invalid URL scheme
          container.innerHTML = '<div class="error">Invalid image URL</div>';
          return;
        } else {
          container.innerHTML = '<div class="error">Could not display card</div>';
          return;
        }
        
        wrapper.appendChild(cardLink);
        
        // Create footer
        const footer = document.createElement('a');
        footer.href = `https://kojira.github.io/NostrDraw/?view=${encodeURIComponent(eventId)}`;
        footer.target = '_blank';
        footer.className = 'card-footer';
        
        // Avatar
        if (avatarUrl && isValidImageUrl(avatarUrl)) {
          const avatar = document.createElement('img');
          avatar.src = avatarUrl;
          avatar.alt = displayName;
          avatar.className = 'avatar';
          avatar.onerror = () => { avatar.style.display = 'none'; };
          footer.appendChild(avatar);
        } else {
          const avatarPlaceholder = document.createElement('div');
          avatarPlaceholder.className = 'avatar';
          avatarPlaceholder.style.background = `hsl(${parseInt(event.pubkey.slice(0, 8), 16) % 360}, 60%, 70%)`;
          footer.appendChild(avatarPlaceholder);
        }
        
        // User info
        const userInfo = document.createElement('div');
        userInfo.className = 'user-info';
        
        const userName = document.createElement('div');
        userName.className = 'user-name';
        userName.textContent = displayName;
        userInfo.appendChild(userName);
        
        const postTime = document.createElement('div');
        postTime.className = 'post-time';
        postTime.textContent = formatDateTime(event.created_at);
        userInfo.appendChild(postTime);
        
        footer.appendChild(userInfo);
        
        // External link icon
        const linkIcon = document.createElement('div');
        linkIcon.innerHTML = `<svg class="nostr-logo" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" stroke="#888" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <polyline points="15 3 21 3 21 9" stroke="#888" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <line x1="10" y1="14" x2="21" y2="3" stroke="#888" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>`;
        footer.appendChild(linkIcon);
        
        wrapper.appendChild(footer);
        
        container.innerHTML = '';
        container.appendChild(wrapper);
        
      } catch (e) {
        console.error('Render error:', e);
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error';
        errorDiv.textContent = `Error: ${e.message}`;
        container.innerHTML = '';
        container.appendChild(errorDiv);
      }
    }

    render();
  </script>
</body>
</html>
